## Fox Telegram Summarizer Bot

Telegram-бот для автоматического создания сводок сообщений из групп с использованием OpenAI и распознавания речи для голосовых сообщений через WhisperX. Бот собирает сообщения из указанных каналов, группирует их по темам и создает краткие сводки.

### Возможности

- **Сбор сообщений**: автоматически собирает все текстовые сообщения из указанных каналов или групп
- **Распознавание голосовых сообщений**: транскрибирует аудио через **WhisperX**
- **Фильтрация по релевантности**: фильтрует сообщения с помощью OpenAI перед созданием сводки (опционально)
- **Сводки по темам**: группирует сообщения по темам и создает сводки по 1–2 предложения на тему
- **Структурированный вывод**: использует модели Pydantic с Structured Output от OpenAI для надежного извлечения тем
- **Отображение участников**: опционально показывает список участников для каждой темы со ссылками на профили
- **Ссылки на источники**: генерирует ссылки на оригинальные сообщения
- **Сводки ссылок**: автоматически обрабатывает ссылки в сообщениях (включая субтитры YouTube)
- **Ежедневное автоматическое создание сводок**: запланированные ежедневные сводки через cron или планировщик задач
- **Система шаблонов**: настраиваемое форматирование сводок с использованием шаблонов Jinja2
- **Настройка промптов**: все промпты редактируются через текстовые файлы в директории `prompts/` с поддержкой резервных вариантов
- **Конфигурация для каждого чата**: индивидуальные настройки для каждого чата/канала через `config.yaml`
- **Поддержка часовых поясов**: корректная обработка часовых поясов для ежедневных сводок в Docker-контейнерах
- **Логирование LLM**: подробное логирование всех запросов/ответов LLM для отладки

---

## Настройка бота в BotFather

Перед использованием бота необходимо создать его и получить токен от Telegram BotFather.

### 1. Создание нового бота

1. Откройте Telegram и найдите `@BotFather`
2. Начните диалог с BotFather
3. Отправьте команду `/newbot`
4. Следуйте инструкциям:
   - Выберите имя для вашего бота (например, "Мой бот-сводчик")
   - Выберите username для вашего бота (должен заканчиваться на `bot`, например, `my_summarizer_bot`)

### 2. Получение токена бота

После создания бота BotFather отправит вам сообщение с токеном бота. Он выглядит так:

```
1234567890:AAExampleBotToken1234567890
```

**Важно:** Храните этот токен в секрете! Никогда не коммитьте его в систему контроля версий и не публикуйте публично.

### 3. Установка описания бота (опционально)

Вы можете опционально установить описание для вашего бота:

```
/setdescription
```

Затем выберите вашего бота и укажите описание, например:
```
Telegram-бот для автоматического создания сводок сообщений из каналов с использованием OpenAI.
```

### 4. Настройка команд бота (опционально)

Бот использует стандартные команды (`/summarize`, `/clear`), которые работают автоматически. Однако вы можете зарегистрировать их в BotFather для лучшего пользовательского опыта:

```
/setcommands
```

Выберите вашего бота и добавьте следующие команды:
```
summarize - Создать сводку сообщений для текущего чата
clear - Очистить сохраненные сообщения для текущего чата
```

### 5. Добавление бота в ваши каналы

После создания бота вам необходимо:

1. Добавить бота в целевые каналы как **администратора**
2. Предоставить боту разрешение на **чтение сообщений**
3. Бот автоматически начнет собирать сообщения из настроенных каналов

**Примечание:** Бот должен быть добавлен как администратор с правами на чтение сообщений для корректной работы.

---

## Установка (без Docker)

1. **Клонирование репозитория**

```bash
git clone https://github.com/<your-username>/fox_tg_summarizer_bot.git
cd fox_tg_summarizer_bot
```

2. **Создание и активация виртуального окружения (рекомендуется)**

```bash
python -m venv venv
source venv/bin/activate      # Linux / macOS
# или
venv\Scripts\activate         # Windows
```

3. **Установка системных зависимостей**

WhisperX требует установки `ffmpeg` в вашей системе:

**Linux (Ubuntu/Debian):**
```bash
sudo apt update
sudo apt install ffmpeg
```

**macOS:**
```bash
brew install ffmpeg
```

**Windows:**
Скачайте с https://ffmpeg.org/download.html и добавьте в PATH

4. **Установка зависимостей Python**

```bash
pip install --upgrade pip
pip install -r requirements.txt
```

4. **Создание файла `.env`**

Создайте файл `.env` в корне проекта и заполните необходимые переменные:

```env
# Telegram
BOT_TOKEN=1234567890:AAExampleBotToken
TRASH_CHAT_ID=

# Каналы для мониторинга (ID и/или username, через запятую)
CHANNEL_ID=-1001234567890,-1009876543210
CHANNEL_USERNAME=@my_channel,@another_channel

# OpenAI
OPENAI_API_KEY=sk-openai-api-key
OPENAI_BASE_URL=https://api.openai.com/v1
OPENAI_MODEL=gpt-4o-mini
OPENAI_MIN_DELAY_S=0.5
OPENAI_MAX_RETRIES=5
OPENAI_BACKOFF_BASE_S=1.0
OPENAI_BACKOFF_MAX_S=30.0


# База данных SQLite
SQLITE_DB_PATH=data/messages.db
```

**Описание переменных окружения**

- **BOT_TOKEN** – токен Telegram-бота от `@BotFather`
- **TRASH_CHAT_ID** – опциональный ID чата (личный чат/группа с ботом), используемый для безопасной проверки существования сообщений
- **CHANNEL_ID** – один или несколько числовых ID каналов, разделенных запятой (например, `-1001234567890,-1009876543210`)
- **CHANNEL_USERNAME** – один или несколько username каналов, разделенных запятой (например, `@my_channel,@another_channel`)
- **OPENAI_API_KEY** – ваш API-ключ OpenAI
- **OPENAI_BASE_URL** – базовый URL для API OpenAI (по умолчанию: `https://api.openai.com/v1`)
- **OPENAI_MODEL** – название модели для создания сводок (по умолчанию: `gpt-4o-mini`)
- **OPENAI_MIN_DELAY_S / OPENAI_MAX_RETRIES / OPENAI_BACKOFF_BASE_S / OPENAI_BACKOFF_MAX_S** – настройки ограничения скорости и повторных попыток/задержек для запросов к OpenAI
- **SQLITE_DB_PATH** – путь к файлу базы данных SQLite (по умолчанию `data/messages.db`)

5. **Создание директории для базы данных (при необходимости)**

Убедитесь, что директория `data/` существует, чтобы SQLite мог создать `messages.db`:

```bash
mkdir -p data
```

6. **Запуск бота**

```bash
python bot.py
```

---

## Запуск с Docker

Этот проект включает `Dockerfile` и `docker-compose.yml` для удобного развертывания.

### 1. Создание `.env`

Создайте файл `.env` в корне проекта с теми же переменными, что описаны выше в разделе **Установка (без Docker)**. Этот файл будет подключен в контейнер через `env_file` в `docker-compose.yml`.

### 2. Запуск с Docker Compose

```bash
docker-compose up --build -d
```

Это выполнит:

- Сборку образа из локального `Dockerfile`
- Запуск контейнера с именем `fox_tg_summarizer_bot`
- Подключение локальной директории `./data` в `/app/data` внутри контейнера, чтобы база данных SQLite (`data/messages.db`) сохранялась

### 3. Логи и управление

- Просмотр логов:

```bash
docker-compose logs -f
```

- Остановка бота:

```bash
docker-compose down
```

---

## Как получить `CHANNEL_ID`

1. Добавьте вашего бота в целевой канал как администратора (с разрешением на чтение сообщений)  
2. Перешлите любое сообщение из этого канала в `@userinfobot`  
3. Скопируйте ID чата из ответа (он будет начинаться с `-100`) и используйте его в `CHANNEL_ID`

---

## Использование

### Базовое использование

1. Убедитесь, что бот запущен (локально или в Docker)
2. Добавьте бота в желаемые каналы как администратора с правами на чтение сообщений
3. Бот автоматически начнет собирать сообщения из настроенных каналов
4. Для создания сводки отправьте команду в чат с ботом:

```text
/summarize
```

5. Для очистки сохраненных сообщений для текущего чата:

```text
/clear
```

### Ежедневное автоматическое создание сводок

Для включения автоматических ежедневных сводок:

1. Установите `daily_enabled: true` в `config.yaml` для вашего чата
2. Настройте `daily_time` (например, `"23:00"`) в вашем часовом поясе
3. Настройте cron-задачу или планировщик задач для запуска `daily_summary.py`:

**Пример cron (запуск каждый день в 00:00 UTC):**
```bash
0 0 * * * cd /path/to/fox_tg_summarizer_bot && /path/to/venv/bin/python daily_summary.py
```

**Пример использования Python schedule (включен в бота):**
Бот включает планировщик, который может автоматически запускать ежедневные сводки. См. `daily_summary.py` для подробностей.

**Примечание:** Бот автоматически преобразует `daily_time` из указанного вами часового пояса в UTC, обеспечивая корректную работу в Docker-контейнерах независимо от часового пояса контейнера.

### Сводки ссылок

Бот может автоматически обрабатывать ссылки в сообщениях:

- **Обычные ссылки**: Загружает содержимое и создает краткую сводку, сохраняемую в тексте сообщения
- **Ссылки YouTube**: Извлекает субтитры и создает сводки

Включите обработку ссылок в `config.yaml`:
- `links_summarize: true` – обрабатывает все ссылки
- `links_summarize_show: true` – отправляет сводку как отдельное сообщение в чат
- `youtube_summarize: true` – обрабатывает только ссылки YouTube
- `youtube_summarize_show: true` – отправляет сводку YouTube в чат

**Ограничения:**
- Максимум 3 ссылки на сообщение
- Максимум 16000 символов содержимого на ссылку

---

## Конфигурация

### Переменные окружения (`.env`)

См. раздел **Установка** выше для необходимых переменных окружения.

### Конфигурация для каждого чата (`config.yaml`)

Вы можете настроить поведение создания сводок для каждого чата (по `chat_id` или `username`) используя `config.yaml`. 

**Начало работы:**
1. Скопируйте `config.yaml.example` в `config.yaml`
2. Настройте параметры для ваших каналов (см. `config.yaml.example` для подробных объяснений)

**Базовый пример:**

```yaml
defaults:
  timezone: "Europe/Moscow"  # или "+03:00"
  topics:
    only_top: false
    min_messages: 5
    max_topics: 0  # 0 = без ограничений
    show_users: false
    user_list_length: 10
  summarize:
    command_enabled: true
    daily_enabled: false
    day_start_time: "06:00"
    daily_time: "23:00"
    max_output_tokens: 0  # 0 = без ограничений (рекомендуется, если ответы обрезаются)
  links_summarize: false
  links_summarize_show: false
  youtube_summarize: false
  youtube_summarize_show: false

chats:
  "-1001234567890":
    topics:
      only_top: false
      min_messages: 3
      max_topics: 10
    summarize:
      daily_enabled: true
      daily_time: "10:00"
    links_summarize: true
    links_summarize_show: true
```

**Параметры конфигурации:**

**Часовой пояс (`timezone`):**
- Поддерживает формат IANA (`"Europe/Moscow"`) или смещение UTC (`"+03:00"`)
- Используется для преобразования `daily_time` и `day_start_time` в UTC
- Может быть установлен глобально в `defaults` или переопределен для каждого чата

**Темы (`topics`):**
- `only_top` – если `true`, включаются только темы с минимум `min_messages` сообщений
- `min_messages` – минимальное количество сообщений в теме для включения
- `max_topics` – максимальное количество тем в сводке (0 = без ограничений)
- `show_users` – если `true`, показывает список участников для каждой темы со ссылками на профили
- `user_list_length` – максимальное количество участников для отображения (0 = без ограничений)

**Создание сводок (`summarize`):**
- `command_enabled` – включить/выключить команду `/summarize`
- `daily_enabled` – включить автоматическое ежедневное создание сводок
- `day_start_time` – начало дня для расчета окна сообщений (формат: `"HH:MM"`)
- `daily_time` – время отправки ежедневной сводки (формат: `"HH:MM"`, в указанном часовом поясе)
- `summarize_template` – путь к пользовательскому шаблону Jinja2 (относительно корня проекта)
- `no_clear_after_summarize` – если `true`, сообщения не архивируются после создания сводки
- `max_output_tokens` – максимальное количество токенов для ответа LLM при создании сводки
  - `0` или не указано – без ограничений (рекомендуется, если ответы обрезаются)
  - Положительное число – максимальное количество токенов в ответе
  - Если ответ не помещается в `max_output_tokens`, сводка может не быть выведена или быть обрезана
  - По умолчанию в коде: 65535 для структурированного вывода, 32000 для резервного варианта
  - Пример: `max_output_tokens: 0` для отключения ограничения

**Распознавание голоса:**
- `voice_recognition_enabled` – включить/выключить распознавание голосовых сообщений через WhisperX
  - `true` – бот будет автоматически транскрибировать голосовые сообщения, аудиофайлы и видеосообщения и сохранять транскрибированный текст в БД
  - `false` – распознавание отключено (по умолчанию)
  - Требует установки `ffmpeg` в системе и библиотеки `whisperx`
  - Пример: `voice_recognition_enabled: true` для включения распознавания

**Сводки ссылок:**
- `links_summarize` – если `true`, загружает и создает сводку содержимого ссылки для хранения в БД
- `links_summarize_show` – если `true`, отправляет сводку ссылки как отдельное сообщение в чат
- `youtube_summarize` – если `true`, обрабатывает только ссылки YouTube (использует субтитры)
- `youtube_summarize_show` – если `true`, отправляет сводку YouTube как отдельное сообщение

**Идентификация чата:**

Ключи в `chats` могут быть:
- Строка `chat_id` (например, `"-1001234567890"`)
- `username` канала/группы без `@` и в нижнем регистре (например, `"cords_community"`)

См. `config.yaml.example` для подробных объяснений и примеров.

---

## Структура проекта

```text
fox_tg_summarizer_bot/
├── bot.py                     # Точка входа: запуск бота
├── config.py                  # Конфигурация, загружаемая из переменных окружения
├── config.yaml                # Конфигурация создания сводок для каждого чата
├── config.yaml.example        # Пример конфигурации с подробными комментариями
├── daily_summary.py           # Скрипт для ежедневного автоматического создания сводок
├── handlers/
│   └── messages.py            # Обработчики сообщений и команд
├── services/
│   ├── db.py                  # Слой базы данных SQLite
│   ├── openai_service.py      # Интеграция с API OpenAI с Structured Output
│   ├── whisper_service.py     # Интеграция WhisperX для распознавания речи
│   ├── summarizer.py          # Логика создания сводок
│   └── link_summarizer.py     # Создание сводок содержимого ссылок
├── utils/
│   ├── prompt_loader.py       # Утилиты загрузки промптов
│   ├── formatter.py           # Форматирование вывода с шаблонами Jinja2
│   └── chat_config.py         # Конфигурация чата и обработка часовых поясов
├── prompts/                   # Текстовые файлы с промптами (редактируемые)
│   ├── relevance_prompt.txt
│   ├── relevance_prompt_fallback.txt
│   ├── summarization_prompt.txt
│   ├── summarization_prompt_fallback.txt
│   ├── structured_system_prompt.txt
│   ├── structured_user_prompt.txt
│   └── fallback_user_prompt.txt
├── templates/                 # Шаблоны Jinja2 для форматирования сводок
│   └── summarize_default.txt  # Шаблон сводки по умолчанию
├── data/                      # База данных SQLite и связанные файлы
├── logs/                      # Логи запросов/ответов LLM
│   ├── llm_chat.log
│   └── llm_structured.log
├── docker-compose.yml         # Конфигурация Docker Compose
├── Dockerfile                 # Определение Docker-образа
├── requirements.txt           # Зависимости Python
├── test_summarizer.py         # Примеры тестов для создания сводок
└── README.md                  # Документация проекта
```

---

## Настройка промптов

Вы можете настроить промпты в папке `prompts/`. Все промпты поддерживают цепочки резервных вариантов: если основной файл отсутствует, бот использует резервный файл, а если и он отсутствует, используется встроенный промпт.

**Основные промпты:**
- `relevance_prompt.txt` – промпт для фильтрации сообщений по релевантности
- `summarization_prompt.txt` – промпт для генерации сводок

**Резервные промпты:**
- `relevance_prompt_fallback.txt` – резервный вариант для промпта релевантности
- `summarization_prompt_fallback.txt` – резервный вариант для промпта создания сводок

**Промпты Structured Output:**
- `structured_system_prompt.txt` – системный промпт для структурированного вывода (определяет модели Pydantic)
- `structured_user_prompt.txt` – пользовательский промпт для структурированного вывода (с плейсхолдером `{messages_text}`)
- `fallback_user_prompt.txt` – резервный промпт для обычного вывода (с плейсхолдером `{messages_text}`)

**Пользовательские промпты для каждого чата:**

Вы можете указать пользовательские промпты в `config.yaml`:
```yaml
chats:
  "-1001234567890":
    topics:
      prompt: "prompts/custom_summarization_prompt.txt"
      structured_system_prompt: "prompts/custom_structured_system_prompt.txt"
```

Изменения в этих файлах повлияют на то, как бот группирует и создает сводки по темам. Промпты загружаются асинхронно при первом использовании.

## Система шаблонов

Бот использует шаблоны Jinja2 для форматирования сводок. Вы можете настроить формат вывода, создав собственный шаблон.

**Шаблон по умолчанию:** `templates/summarize_default.txt`

**Пример пользовательского шаблона:**

Создайте `templates/my_template.txt`:
```html
<b>{{ header }}</b>

{% for topic in topics %}
• {% if topic.link %}<a href="{{ topic.link }}">{{ topic.topic }}</a>{% else %}{{ topic.topic }}{% endif %}{% if topic.message_count > 1 %} ({{ topic.message_count }}){% endif %}. {{ topic.description }}{% if topic.participants %}
<i>{{ topic.participants | join(', ') }}</i>{% endif %}

{% endfor %}
{{ footer }}
```

**Доступные переменные шаблона:**
- `{{ header }}` – заголовок сводки (по умолчанию: "Сегодня обсуждали:")
- `{{ topics }}` – список тем (цикл с `{% for topic in topics %}`)
  - `topic.topic` – название темы
  - `topic.link` – ссылка на первое сообщение (может быть пустой)
  - `topic.description` – описание темы
  - `topic.message_count` – количество сообщений в теме
  - `topic.participants` – отформатированный список участников (если `show_users=true`)
- `{{ footer }}` – подвал сводки (по умолчанию: "#summarize")

**Использование пользовательского шаблона:**

Укажите в `config.yaml`:
```yaml
chats:
  "-1001234567890":
    summarize:
      summarize_template: "templates/my_template.txt"
```

Если пользовательский шаблон не найден, бот использует резервный вариант `templates/summarize_default.txt`, а если и он отсутствует, используется встроенный резервный шаблон.

## Structured Output

Бот использует функцию Structured Output от OpenAI с моделями Pydantic для надежного извлечения тем:

- **Основной метод**: API `responses.parse` (предпочтительно)
- **Резервный метод**: API `beta.chat.completions.parse`
- **Финальный резервный вариант**: Обычные chat completions с парсингом текста

**Преимущества:**
- Надежное извлечение тем с валидированными структурами данных
- Список участников с ID/username пользователей и количеством сообщений
- Автоматическая сортировка по активности (количество сообщений на тему)
- Оптимизация токенов (возвращает только первый ID сообщения на тему)

**Модели Pydantic:**
- `TopicItem` – тема с описанием, ID сообщений (ограничено до 1) и списком участников
- `TopicsResponse` – ответ, содержащий список тем

Все запросы структурированного вывода логируются в `logs/llm_structured.log` для отладки.

---

## Логирование

Бот предоставляет подробное логирование для отладки и мониторинга:

**Логи запросов/ответов LLM:**
- `logs/llm_chat.log` – обычные chat completions
- `logs/llm_structured.log` – запросы структурированного вывода

Оба лога включают:
- Параметры запроса (модель, сообщения, температура и т.д.)
- Содержимое ответа и метаданные
- Использование токенов (промпт, завершение, всего)
- Длина ответа и причина завершения
- Временные метки

**Запуски ежедневных сводок:**
- `logs/last_daily_runs.json` – отслеживает время последнего запуска для каждого чата для предотвращения дублирующих запусков

**Логи приложения:**
- Стандартный вывод/ошибки для общих операций бота
- Логи Docker через `docker-compose logs -f`

## Примеры вывода сводок

**Пример с участниками (`show_users: true`):**

```
Сегодня обсуждали:

- Планирование сходки (https://t.me/c/2340656226/104590) (30). Обсуждение идей для предстоящей сходки, включая бейджи, форматы джемов и музыкальные инструменты.

(Леонид,Alex Vans,Niko Niko)

- Обсуждение нового проекта (https://t.me/c/2340656226/104591) (15). Планирование архитектуры и выбор технологий.

(Иван Петров,Мария Смирнова)

#summarize
```

**Пример без участников (`show_users: false`):**

```
Сегодня обсуждали:

- Планирование сходки (https://t.me/c/2340656226/104590) (30). Обсуждение идей для предстоящей сходки, включая бейджи, форматы джемов и музыкальные инструменты.

- Обсуждение нового проекта (https://t.me/c/2340656226/104591) (15). Планирование архитектуры и выбор технологий.

#summarize
```

**Возможности:**
- Каждая тема включает ссылку на первое сообщение
- Количество сообщений в скобках после ссылки
- Участники отсортированы по активности (если включено)
- Имена участников отформатированы как ссылки, если доступен username

## Технологический стек

**Backend (Python):**
- `aiogram 3.13.1` – фреймворк Telegram Bot API
- `openai 1.54.3` – клиент API OpenAI с поддержкой Structured Output
- `aiosqlite 0.20.0` – асинхронный доступ к SQLite
- `httpx 0.27.2` – асинхронный HTTP-клиент для внешних API
- `aiofiles 24.1.0` – асинхронные файловые операции
- `pydantic 2.9.2` – валидация данных и Structured Output
- `PyYAML 6.0.2` – парсинг конфигурации YAML
- `youtube-transcript-api 0.6.2` – извлечение субтитров YouTube
- `markdownify 0.13.1` – преобразование HTML в Markdown
- `schedule` – планировщик задач
- `python-dotenv 1.0.1` – загрузка переменных окружения
- `Jinja2 3.1.4` – движок шаблонов для форматирования сводок
- `whisperx` – библиотека распознавания речи
- `torch` – PyTorch (требуется для WhisperX)
- `torchaudio` – обработка аудио PyTorch (требуется для WhisperX)

**База данных:**
- SQLite с режимом WAL для лучшей конкурентности

**Внешние API:**
- API OpenAI (или любой совместимый API через `OPENAI_BASE_URL`)

**Распознавание речи:**
- WhisperX — локальная библиотека для транскрибирования голоса

## Заметки и рекомендации для продакшена

- Бот хранит сообщения в базе данных SQLite в `data/messages.db` (режим WAL включен для лучшей производительности)
- Убедитесь, что у бота есть разрешение на чтение сообщений в целевых каналах (добавьте как администратора)
- Транскрибирование голосовых сообщений использует локальную библиотеку WhisperX (только если `voice_recognition_enabled: true` в `config.yaml`, требует установки ffmpeg в системе)
- Бот поддерживает любой совместимый с OpenAI API через `OPENAI_BASE_URL` (полезно для локальных моделей или прокси)
- **Обработка часовых поясов**: Бот корректно обрабатывает часовые пояса в Docker-контейнерах, преобразуя все времена во внутренний UTC
- **Оптимизация токенов**: Возвращается только первый ID сообщения на тему для экономии токенов; полное количество сообщений все еще отслеживается
- **Ограничения токенов вывода**: Настройте `max_output_tokens` в `config.yaml` для контроля длины ответа LLM (установите `0` для отключения ограничения, если ответы обрезаются)
- **Ограничение скорости**: Встроенная экспоненциальная задержка для ошибок 429 и регулирование для предотвращения ограничений скорости
- **Архивирование сообщений**: Сообщения автоматически архивируются после успешного создания сводки (может быть отключено с `no_clear_after_summarize: true`)
- Для более высокой надежности и масштабируемости вы можете заменить SQLite на внешнюю базу данных и расширить слой `services/db.py`
- **Отображение участников**: Когда `show_users: true`, участники сортируются по активности и форматируются со ссылками на профили (если доступен username)

---

## Вклад в проект

Вклад очень приветствуется! Если вы хотите сообщить об ошибке, предложить функцию или отправить pull request, пожалуйста, следуйте этим рекомендациям:

- **Сделайте форк** репозитория и создайте ветку функции (например, `feature/add-new-command`)
- **Следуйте существующему стилю** и структуре кодовой базы (обработчики в `handlers/`, сервисы в `services/`, утилиты в `utils/`)
- **Держите изменения сфокусированными** – старайтесь сделать каждый PR об одном логическом изменении
- **Обновляйте или добавляйте тесты** в `test_summarizer.py`, если вы изменяете логику создания сводок или другое критическое поведение
- **Документируйте изменения, видимые пользователю** в `README.md` или комментариях к коду, где это уместно
- **Не коммитьте секреты** – никогда не коммитьте `.env` или любые реальные токены/ключи

Для более подробной информации см. специальный файл [CONTRIBUTING.md](CONTRIBUTING.md).

---

## Лицензия

Этот проект лицензирован под **MIT License** – см. файл `LICENSE` для подробностей.

